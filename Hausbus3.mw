{{ProjektInfoBox
|name        = Hausbus3
|status      = experimental
|image       = RaumZeitLabor - Logo - Schwarz.svg
|description = 
|author      = [[Benutzer:Tiefpunkt|tiefpunkt]], [[Benutzer:Else|else]]
|maintainer  = [[Benutzer:Else|else]]
|username    = 
|version     = v3.0.1
|update      = 
|platform    = 
|hostname    = 
|license     = 
|download    = 
}}
Auf besonderen Wunsch wurde aus der kontinuierlichen Weiterentwicklung des [[Hausbus2]] nun der '''Hausbus3'''. Er setzt auf ähnlichen Konzepten auf, ergänzt aber viel sinnvolles noch dazu.

Die Kommunikation auf dem Hausbus3 erfolgt via Message Queues, in diesem Falle MQTT. Zusätzlich ist es je nach Implementierung möglich, über HTTP und HTTPS mit kommunizieren, um auch ohne MQTT auf gewissen Dienste direkt zugreifen zu können.

Vorschläge und Kritik am Konzept sind gerne gesehen.

== Überlegungen ==
Der [[Hausbus2]] sieht ein Pull-Prinzip vor. Ein Teilnehmer, der über Events oder Sensorwerte benachrichtigt werden möchte, muss aktiv Geräte pollen, um den aktuellen Status zu erfahren, und somit eine eventuelle Änderung mitzubekommen.

Nachteile:
* Geräte müssen bekannt sein, nachträgliches Hinzufügen ist nur schwierig möglich.
* Polling ist doof.

Alternative: Messages werden von den Endgeräten an einen Server gepusht. Hierfür eignet sich z.B. Pubsub Protokoll.

Nach einigen Überlegungen wurde MQTT als Protokoll ausgewählt. Gründe für die Auswahl:
* Lightweight, läuft z.B. auch auf Arduinos
* Leicht zu implementieren, Libraries für viele Sprachen
* Last-Will-Funktion (was passiert wenn Endgerät Verbindung verliert)
* bei (Re-)Connect können neue Geräte über das letzte Event informiert werden
* Authentifizierung, ACLs etc. möglich.

== Low-Cost Devices ==

''Es folgen einige Überlegungen, wie man Arduinos etc. günstig an den Broker anbinden kann.''

Leider eignet sich MQTT eher schlecht für kostengünstige Endgeräte wie z.B. einfache Mikrocontroller. Da man nicht unbedingt für jeden Sender einen Raspberry Pi o.ä. verschwenden möchte, stellt sich die Frage nach einer günstigen Anbindung an unseren Broker, die keinen Ethernet bzw. TCP Stack benötigt.

=== Spannungsversorgung ===

Für Low-Cost Devices möchte man eigentlich irgendwas cooleres als ein Steckernetzteil zur Spannungsversorgung. Zum Einen belegt jedes Netzteil eine Steckdose, zum anderen ist es auch schlichtweg ineffizient. [[Benutzer:DancingFo|DancingFo]] und [[Benutzer:Else|Else]] überlegen, eine 24V Spannungsversorgung durch unsere Räume zu ziehen, die von einem Hutschienennetzteil (wie z.B. dem [https://secure.reichelt.de/Schaltnetzteile-fuer-Hut-Schiene/SNT-MW-DR60-24/3/index.html?&ACTION=3&LA=2&ARTICLE=85231&GROUPID=4961&artnr=SNT+MW-DR60-24 SNT MW-DR60-24]) versorgt wird. Da die Leitungslänge recht groß sein wird (und damit auch der Spannungsabfall), nimmt man vermutlich besser 24V.

Nachteil von 24V ist, dass die Arduinos nicht mehr direkt an der Strippe betrieben werden können. Es gibt aber einstellbare Spannungswandler für wenig Geld (siehe z.B. [http://www.electrodragon.com/product/lm2596s-adj-dc-dc-small-tiny-adjustable-step-down-module-3-40vin-1-5-35vout/ LM2596S]) mit bis zu 3A, die man entweder zentral je Raum installiert, oder an jedem Arduino (auf einer Basisplatine).

=== Kommunikation ===

Kabelgebundene Busse wie z.B. CAN oder RS485 haben zwar hohe Reichweiten, allerdings ist der Aufwand für die Verlegung des Kabels relativ hoch, da wir auf jedenfall möglichst an jeder Stelle im Raum Geräte anbinden können möchten. Unabhängig davon sind Abzweigungen nicht so einfach möglich, bzw. nur sehr kurz an der Hauptleitung.

Es bietet sich daher eine Funkübertragung an. Als sehr günstig stellen sich die NRF24L01 Funkmodule auf 2.4Ghz Basis heraus (ca. 1-2€ pro Modul). Die Reichweite soll unter normalen Bedingungen bis zu 30M betragen, es gibt allerdings auch eine Funkmodulversion mit rausgeführter Antenne, die eine deutlich höhere Reichweiten erreicht (leicht teurer, aber auch nicht mehr als 3-4€). Libraries für Atmel, Arduino und Linux (Raspberry Pi) gibt es bereits.

Man könnte ein NRF24L01 Shield für den Raspberry Pi o.ä. entwerfen, der dann wieder die empfangenen Datenpakete auf den MQTT Broker ausleitet. Hierzu würde dann auch noch ein einfaches Protokoll benötigt.

== Topics ==

Im Mai 2014 haben wir begonnen, die ersten Services mit unserem Broker [[Mate (Server)/infra.rzl|infra.rzl]] zu verbinden. Es folgt eine Liste von Topics, die momentan auf dem Broker gepublished werden.

''Legende: F=freigegeben, r=retained, q=QoS, b=blacklisted (Änderungen werden nicht gespeichert)''

{| class="wikitable"
! style="font-weight: bold;" | Topic
! style="font-weight: bold;" | F
! style="font-weight: bold;" | R
! style="font-weight: bold;" | Q
! style="font-weight: bold;" | B
! style="font-weight: bold;" | Format
! style="font-weight: bold;" | Thing
! style="font-weight: bold;" | Source
! style="font-weight: bold;" | Kommentare
! style="font-weight: bold;" | Kontakt
|-
| /service/fnordcredit/transactions
| X
| 
| 0
| X
| application/json
| [[Fnordcredit]]
| [[Mate (Server)/cashdesk.rzl|cashdesk.rzl]]
| User, Delta
| [[Benutzer:silsha|silsha]]
|-
| /service/mpd/song
| X
| 
| 0
| 
| application/json
| [[MPD]]
| [[Mate (Server)/infra.rzl|infra.rzl]]
| aktueller Track; leeres Objekt, wenn momentan nichts abgespielt wird
| [[Benutzer:Else|else]]
|-
| /service/mpd/state
| 
| X
| 0
| 
| application/json
| [[MPD]]
| [[Mate (Server)/infra.rzl|infra.rzl]]
| Zustand des MPDs. "play", "pause", "stop
| [[Benutzer:Else|else]]
|-
| /service/status
| X
| X
| 0
| X
| application/json
| [[Raumstatus|Tür]]
| [[Pinpad]]
| Status der Tür (bzw. des Schlosses)
| [[Benutzer:Else|else]]
|-
| /service/status/presence
| X
| X
| 1
| X
| application/json
| [[Raumstatus|Tür]]
| [[Mate (Server)/infra.rzl|infra.rzl]]
| Identifizierte Laboranten
| [[Benutzer:Else|else]]
|-
| /service/status/devices
| X
| 
| 0
| 
| application/json
| [[Mate (Server)/unifi.vm.rzl|WLAN]]
| [[Mate (Server)/infra.rzl|infra.rzl]]
| Anzahl Geräte im WLAN
| [[Benutzer:Else|else]]
|-
| /service/plug/$plugname/state
| X
| X
| 0
| 
| application/json
| [[Funksteckdosen|Steckdose]]
| [[Mate (Server)/infra.rzl|infra.rzl]]
| Zustand der Steckdosen
| [[Benutzer:Else|else]]
|-
| /service/plug/$plugname/power
| X
| 
| 0
| 
| application/json
| [[Funksteckdosen|Steckdose]]
| [[Mate (Server)/infra.rzl|infra.rzl]]
| aktueller Stromverbrauch
| [[Benutzer:Else|else]]
|-
| /service/plug/$plugname/consumption
| X
| 
| 0
| 
| application/json
| [[Funksteckdosen|Steckdose]]
| [[Mate (Server)/infra.rzl|infra.rzl]]
| ''?''
| [[Benutzer:Else|else]]
|-
| /service/plug/$plugname/consumptionTotal
| X
| 
| 0
| 
| application/json
| [[Funksteckdosen|Steckdose]]
| [[Mate (Server)/infra.rzl|infra.rzl]]
| ''?''
| [[Benutzer:Else|else]]
|}

Beispiel zum Subscriben auf der Kommandozeile (offizieller Client):

<pre>mosquitto_sub -h infra.rzl -t /service/status/presence</pre>

== XKeyScore ==

[[Benutzer:Else|Else]] hat ein kleines [https://github.com/raumzeitlabor/rzl-xkeyscore Perlscript] geschrieben, was sich auf das Topics '#' (alle Topics) subscribed und die Daten in unsere MySQL auf db.rzl schiebt, sodass wir später beliebige Statistiken bauen können. Bestimmte Topics können hiervon ausgeschlossen werden (bitte schicke einen Pullrequest). Momentan ist das insbesondere der Anwesenheitsstatus. Hier ein Beispiel, wie Du die Daten auslesen kannst:

<pre>1 % mysql --user=xkeyscore-ro --host=db.rzl --password=iedeijuophae6el4xeiniphac9ohqui4 xkeyscore
[...]
mysql> select * from messages order by `when` desc limit 1;
+-----+--------------------------------+---------+------+---------------------+--------+
| id  | topic                          | payload | qos  | when                | retain |
+-----+--------------------------------+---------+------+---------------------+--------+
| 421 | /service/plug/pinkelampe/power | 0       |    0 | 2014-06-29 17:13:52 |      0 |
+-----+--------------------------------+---------+------+---------------------+--------+
1 row in set (0.00 sec)

mysql> Bye
</pre>

=== Nützliche Abfragen ===

Liefert den Gesamtverbrauch (vermutlich kWh) der Funksteckdosen zurück:
<pre>
mysql> select payload, topic, max(`when`) from messages where topic like "%/consumptionTotal" group by topic;

+------------------+----------------------------------------------------+---------------------+
| payload          | topic                                              | max(`when`)         |
+------------------+----------------------------------------------------+---------------------+
| 0                | /service/plug/ALAAAAAAARM/consumptionTotal         | 2014-09-02 21:52:13 |
| 1.39             | /service/plug/blinklampe/consumptionTotal          | 2014-09-02 21:52:43 |
| 17.0399999999998 | /service/plug/drucker/consumptionTotal             | 2014-09-03 00:24:38 |
| 0.09             | /service/plug/FliegenbratgerÃ¤t/consumptionTotal   | 2014-07-03 06:25:33 |
| 11.07            | /service/plug/infoscreen/consumptionTotal          | 2014-09-03 00:25:05 |
| 0.09             | /service/plug/lampe1/consumptionTotal              | 2014-06-30 06:25:46 |
| 0.39             | /service/plug/lampe2/consumptionTotal              | 2014-09-03 00:24:48 |
| 0.39             | /service/plug/lampe3/consumptionTotal              | 2014-09-03 00:24:44 |
| 9.89             | /service/plug/music/consumptionTotal               | 2014-09-03 00:24:48 |
| 1.42             | /service/plug/pinkelampe/consumptionTotal          | 2014-09-03 00:24:51 |
| 0.25             | /service/plug/pringles/consumptionTotal            | 2014-09-03 00:24:38 |
| 2.42999999999999 | /service/plug/telekom/consumptionTotal             | 2014-09-03 00:24:58 |
+------------------+----------------------------------------------------+---------------------+
</pre>

Liefert die durchschnittliche Leistung des Verbrauchers:

<pre>
mysql> select topic, avg(payload) from messages where topic like "%/power" group by topic;

+-----------------------------------------+--------------------+
| topic                                   | avg(payload)       |
+-----------------------------------------+--------------------+
| /service/plug/ALAAAAAAARM/power         |  5.166666666666667 |
| /service/plug/blinklampe/power          |  60.33076923076923 |
| /service/plug/drucker/power             | 31.727655310621266 |
| /service/plug/FliegenbratgerÃ¤t/power   |  8.343627322690343 |
| /service/plug/infoscreen/power          | 28.659744193874854 |
| /service/plug/lampe1/power              |   8.31785714285716 |
| /service/plug/lampe2/power              | 13.788615123194523 |
| /service/plug/lampe3/power              | 11.749518011161811 |
| /service/plug/music/power               |  44.50110059857108 |
| /service/plug/pinkelampe/power          | 0.9276100086281257 |
| /service/plug/pringles/power            |  7.060912240184901 |
| /service/plug/telekom/power             |  24.22797356828189 |
+-----------------------------------------+--------------------+
</pre>

Liefert die durchschnittliche Gesamtleistung aller Verbraucher:

<pre>
mysql> select sum(k.foo) from (select topic, avg(payload) as foo from messages where topic like "%/power" group by topic) k;

+--------------------+
| sum(k.foo)         |
+--------------------+
| 244.80204941750182 |
+--------------------+
</pre>

== Angebundene Geräte ==

==== [[Mate (Server)/tiefpunkt.vm.rzl|tiefpunkt.vm.rzl]] ====

* Hostet den MQTT-Broker (mosquitto)
* hausbus3-exporters. Exportieren Sensordaten zu aktuell Cosm und OpenTSDB

''(keine Gewährleistung, ob das noch aktuell ist)''

==== [[Heizungssteuerung]] (heizung.rzl) ====

* Temperatursensoren
* Fensterstatus

== Broker ==

==== [[Mate (Server)/infra.rzl|infra.rzl]] ====

* auf infra.rzl läuft ein MQTT Broker für alle zentralen Dienste
* '''TODO:''' eventuell zusätzlich noch mit tiefpunkts bridgen (oder ersetzen)

==== premium.rzl ====

* unsere externe VM. '''Bridge''' auf infra.rzl (keep-alive 10 Sekunden, automatischer Reconnect)
* bridged den gesamten Tree (#) mit QoS Level 2, ''read-only''
* lauscht nur auf internem loopback

==== [[Mate (Server)/tiefpunkt.vm.rzl|tiefpunkt.vm.rzl]] ====
* siehe ''Angebundene Geräte''

== Regelframework ==

Wir sind noch auf der Suche nach einem geeigneten Regelframework (ähnlich IFFT). Momentan experimentieren wir mit [http://nodered.org Node-Red], einem Daemon mit Webinterface vom IBM. Dieser kann [http://infra.rzl:1880/ hier] erreicht werden, und tut momentan folgendes:

* Veröffentlichung des Raumstatus auf @raumzeitstatus

== Code ==
Basis-Implementierung: [https://github.com/raumzeitlabor/hausbus3-python hausbus3-python]

Endpunkte:
* [https://github.com/raumzeitlabor/hausbus3-raumstatus hausbus3-raumstatus]: Transferiert den Raumstatus (Hausbus1) auf den Hausbus3. Tut noch nicht.
* [https://github.com/raumzeitlabor/hausbus3-exporters hausbus3-exporters]: Exportiert auf dem Hausbus3 publizierte Sensorwerte zu Cosm und OpenTSDB.
* [https://github.com/raumzeitlabor/heizungssteuerung heizungssteuerung]: Heizungssteuerung im Hauptraum. Durch die Nicht-Verfügbarkeit von tiefpunkt.vm.rzl aktuell nur in abgespeckter Version.

=== needed ===

* Soundserver, der auf Events reagiert. Es gibt bereits einen simplen [https://github.com/raumzeitlabor/rzl-krachbumms Soundserver], der allerdings nur über HTTP funktioniert. Gewünscht wäre eine modifizierte Version, die sich auf den gesamten /service Tree subscribed (Topic: /service/#) und bei Events auf unserem Datengrab in einem bestimmten Verzeichnis schaut, ob es für das Topic eine gleichnamige Sounddatei gibt, die dann abgespielt wird. Neue Sounds könnte man dann einfach registrieren in dem man Dateien auf dem Datengrab ablegt.

[[Kategorie:Projekt]][[Kategorie:Infrastruktur]]
